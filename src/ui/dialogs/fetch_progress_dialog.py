# Generated by Copilot
# src/ui/dialogs/fetch_progress_dialog.py

import logging
from typing import Dict, List, Any, Optional

from PySide6.QtWidgets import (
    QDialog,
    QVBoxLayout,
    QTableWidget,
    QTableWidgetItem,
    QPushButton,
    QHeaderView,
    QDialogButtonBox,
    QApplication,
    QWidget,
    QHBoxLayout,
    QSizePolicy,
    QProgressBar,
)
from PySide6.QtCore import Qt, Signal, Slot

logger = logging.getLogger(__name__)


class FetchProgressDialog(QDialog):
    """Dialog to show the progress of fetching news from multiple sources."""

    # Signal emitted when a view button is clicked, passing the URL
    view_llm_output_requested = Signal(str)

    # Column constants
    COL_IDX = 0
    COL_NAME = 1
    COL_URL = 2
    COL_STATUS = 3
    COL_ACTION = 4

    # Estimated total steps for a successful fetch per URL
    TOTAL_EXPECTED_STEPS = 12

    def __init__(self, sources: List[Dict[str, Any]], parent=None):
        super().__init__(parent)
        self.setWindowTitle("News Fetch Progress")
        self.setMinimumSize(900, 450)
        self.sources_map: Dict[str, int] = {}  # url -> row_index

        layout = QVBoxLayout(self)

        self.table = QTableWidget()
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels(
            [
                "#",
                "Source",
                "URL",
                "Progress",
                "Details",
            ]
        )
        # Adjust resizing
        self.table.horizontalHeader().setSectionResizeMode(
            QHeaderView.ResizeMode.Stretch
        )  # Default stretch
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_IDX, QHeaderView.ResizeMode.ResizeToContents
        )
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_NAME, QHeaderView.ResizeMode.Interactive
        )  # Allow resize
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_URL, QHeaderView.ResizeMode.Stretch
        )  # Stretch URL
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_STATUS, QHeaderView.ResizeMode.Interactive
        )  # Allow resize status column # Generated by Copilot
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_ACTION, QHeaderView.ResizeMode.ResizeToContents
        )  # Fit button

        self.table.setEditTriggers(QTableWidget.EditTrigger.NoEditTriggers)
        self.table.setWordWrap(False)  # Prevent status wrapping initially

        self.populate_table(sources)
        layout.addWidget(self.table)

        # url -> status update count
        self.status_history = {s["url"]: 0 for s in sources}
        # url -> is_final_status
        self.final_status_flag = {s["url"]: False for s in sources}

    def populate_table(self, sources: List[Dict[str, Any]]):
        """Fills the table with the initial source list."""
        self.table.setRowCount(0)  # Clear existing rows
        self.sources_map.clear()
        self.table.setRowCount(len(sources))

        for idx, source_info in enumerate(sources):
            url = source_info.get("url", f"invalid_url_{idx}")
            self.sources_map[url] = idx

            # Create items
            idx_item = QTableWidgetItem(str(idx + 1))
            name_item = QTableWidgetItem(source_info.get("name", "N/A"))
            url_item = QTableWidgetItem(url)

            # 用进度条替换status列
            progress = QProgressBar()
            progress.setRange(
                0, self.TOTAL_EXPECTED_STEPS
            )  # Set range based on expected steps
            progress.setValue(0)  # Initial value is 0
            progress.setFormat("Pending")  # Initial text
            progress.setAlignment(Qt.AlignmentFlag.AlignCenter)  # Center text
            self.table.setCellWidget(idx, self.COL_STATUS, progress)

            # Set items
            self.table.setItem(idx, self.COL_IDX, idx_item)
            self.table.setItem(idx, self.COL_NAME, name_item)
            self.table.setItem(idx, self.COL_URL, url_item)

            # Add an empty placeholder widget in the action column initially
            # This helps with consistent row height and layout
            placeholder_widget = QWidget()
            placeholder_layout = QHBoxLayout(placeholder_widget)
            placeholder_layout.setContentsMargins(0, 0, 0, 0)
            placeholder_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
            # Example: Add a disabled button
            placeholder_button = QPushButton("View")
            placeholder_button.setEnabled(False)
            placeholder_layout.addWidget(placeholder_button)
            self.table.setCellWidget(idx, self.COL_ACTION, placeholder_widget)

        self.table.resizeColumnsToContents()
        # Re-apply specific resize modes after content might affect ResizeToContents
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_URL, QHeaderView.ResizeMode.Stretch
        )
        self.table.horizontalHeader().setSectionResizeMode(
            self.COL_NAME, QHeaderView.ResizeMode.Interactive
        )
        # Set initial interactive widths
        self.table.setColumnWidth(self.COL_NAME, 150)
        self.table.setColumnWidth(
            self.COL_STATUS, 180
        )  # Increase width for progress bar + text

    @Slot(str, str, bool)
    def update_status(self, url: str, status: str, is_final_status: bool):
        """Updates the status and progress bar for a given URL."""
        if url in self.sources_map:
            if self.final_status_flag.get(url, False):
                return

            row = self.sources_map[url]

            # --- Progress Bar Update ---
            progress_widget = self.table.cellWidget(row, self.COL_STATUS)
            if isinstance(progress_widget, QProgressBar):
                progress = progress_widget
            else:
                # Fallback: create if it wasn't there (shouldn't happen with new init)
                logger.warning(f"Progress bar not found for {url}, creating new one.")
                progress = QProgressBar()
                progress.setRange(0, self.TOTAL_EXPECTED_STEPS)
                progress.setAlignment(Qt.AlignmentFlag.AlignCenter)
                self.table.setCellWidget(row, self.COL_STATUS, progress)

            # Calculate progress value
            self.status_history[url] += 1
            current_step = self.status_history[url]

            if is_final_status:
                self.final_status_flag[url] = True
                progress_value = self.TOTAL_EXPECTED_STEPS
            else:
                # Ensure value doesn't exceed max before final status
                progress_value = min(current_step, self.TOTAL_EXPECTED_STEPS)

            progress.setValue(progress_value)
            progress.setFormat(f"{status}")
            # Set tooltip to show just current status
            progress.setToolTip(
                f"{status} ({progress_value}/{self.TOTAL_EXPECTED_STEPS})"
            )

            # --- Action Button Update ---
            if is_final_status:
                current_widget = self.table.cellWidget(row, self.COL_ACTION)
                button_container = None
                view_button = None

                # Find existing button or create new one
                if (
                    isinstance(current_widget, QWidget)
                    and current_widget.layout()
                    and isinstance(
                        current_widget.layout().itemAt(0).widget(), QPushButton
                    )
                ):
                    # It's the container with the button
                    button_container = current_widget
                    view_button = current_widget.layout().itemAt(0).widget()
                elif isinstance(
                    current_widget, QPushButton
                ):  # Should not happen with container setup
                    view_button = current_widget
                    # Need to wrap it in a container for alignment
                    button_container = QWidget()
                    button_layout = QHBoxLayout(button_container)
                    button_layout.addWidget(view_button)
                    button_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                    button_layout.setContentsMargins(2, 2, 2, 2)
                    self.table.setCellWidget(row, self.COL_ACTION, button_container)
                else:
                    # Replace placeholder or unexpected widget
                    view_button = QPushButton("View")
                    view_button.setToolTip(f"View analysis result for {url}")
                    # Disconnect previous lambda if any before connecting new one
                    try:
                        view_button.clicked.disconnect()
                    except RuntimeError:
                        pass  # No connection existed
                    view_button.clicked.connect(
                        lambda *args, u=url: self._emit_view_request(u)
                    )

                    button_container = QWidget()
                    button_layout = QHBoxLayout(button_container)
                    button_layout.addWidget(view_button)
                    button_layout.setAlignment(Qt.AlignmentFlag.AlignCenter)
                    button_layout.setContentsMargins(2, 2, 2, 2)
                    self.table.setCellWidget(row, self.COL_ACTION, button_container)

                # Ensure button is enabled
                if view_button:
                    view_button.setEnabled(True)

        else:
            logger.warning(f"URL '{url}' not found in progress table map.")

    def _emit_view_request(self, url: str):
        """Helper function to emit the signal."""
        logger.debug(f"View button clicked for URL: {url}")
        self.view_llm_output_requested.emit(url)

    def closeEvent(self, event):
        """Override close event to just hide the dialog."""
        logger.debug("FetchProgressDialog closeEvent triggered, hiding.")
        self.hide()
        event.ignore()

    def reject(self):
        """Override reject (called on Escape or Close button if standard box used)"""
        logger.debug("FetchProgressDialog reject triggered, hiding.")
        self.hide()  # Just hide
